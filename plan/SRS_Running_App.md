# Software Requirements Specification (SRS)
## 러닝 코스 자동 생성 및 추적 모바일 애플리케이션

**문서 버전:** 1.0  
**작성일:** 2024  
**프로젝트명:** Running Map App

---

## 1. 소개 (Introduction)

### 1.1 목적 (Purpose)
이 문서는 안드로이드와 iOS 플랫폼에서 동작하는 러닝 코스 자동 생성 및 러닝 추적 모바일 애플리케이션의 소프트웨어 요구사항을 정의합니다.

### 1.2 범위 (Scope)
이 애플리케이션은 사용자가 원하는 거리를 입력하면 자동으로 러닝 코스를 생성하고, 러닝 중 실시간으로 속도, 페이스, 고저차 등의 정보를 제공합니다. 또한 생성된 코스를 저장하고 다른 사용자와 공유할 수 있는 기능을 제공합니다.

### 1.3 정의, 약어, 약칭 (Definitions, Acronyms, Abbreviations)
- **SRS**: Software Requirements Specification
- **GPS**: Global Positioning System
- **API**: Application Programming Interface
- **OSM**: OpenStreetMap
- **WGS84**: World Geodetic System 1984 (좌표계)
- **Haversine**: 지구 곡률을 고려한 거리 계산 공식
- **TTL**: Time To Live (캐시 유지 시간)

### 1.4 참고 자료 (References)
- Distance-Constrained Loop Generation Algorithm v1.0 문서
- Clean Architecture 원칙
- IEEE 830-1998 SRS 표준

### 1.5 개요 (Overview)
이 문서는 다음 섹션으로 구성됩니다:
- 섹션 2: 전체 설명
- 섹션 3: 시스템 기능 요구사항
- 섹션 4: 비기능 요구사항
- 섹션 5: 시스템 인터페이스 요구사항
- 섹션 6: 제약사항 및 기술적 허들

---

## 2. 전체 설명 (Overall Description)

### 2.1 제품 관점 (Product Perspective)
이 애플리케이션은 독립 실행형 모바일 애플리케이션으로, 백엔드 서버와 통신하여 코스 생성 및 공유 기능을 제공합니다.

### 2.2 제품 기능 (Product Functions)
주요 기능:
1. **맵 표시**: 지도를 로드하고 사용자 위치 표시
2. **거리 입력**: 사용자가 원하는 러닝 거리(km) 입력
3. **코스 생성**: 입력된 거리에 맞는 러닝 코스 자동 생성 및 시뮬레이션
4. **코스 저장**: 생성된 코스를 로컬 및 서버에 저장
5. **코스 로드**: 저장된 코스 불러오기 (자신의 코스 및 다른 사용자 코스)
6. **러닝 추적**: 러닝 중 실시간 속도, 페이스, 고저차, 시간 정보 제공

### 2.3 사용자 특성 (User Characteristics)
- **주요 사용자**: 러닝을 즐기는 일반인
- **기술 수준**: 기본적인 스마트폰 사용 능력
- **필수 요구사항**: GPS 기능이 있는 안드로이드/iOS 기기

### 2.4 제약사항 (Constraints)
- 안드로이드 8.0 (API 26) 이상
- iOS 13.0 이상
- 인터넷 연결 필요 (코스 생성 및 공유 시)
- GPS 권한 필요
- 위치 서비스 활성화 필요

### 2.5 가정 및 종속성 (Assumptions and Dependencies)
- 사용자는 GPS 기능이 활성화된 상태에서 앱을 사용
- 서버는 24/7 가동 상태
- 외부 라우팅 API (OSM, Google Maps, Mapbox 등) 사용 가능
- 지도 API 라이선스 및 사용량 제한 준수

---

## 3. 시스템 기능 요구사항 (System Features)

### 3.1 맵 로드 기능 (FR-001)

#### 3.1.1 설명
앱 실행 시 지도를 로드하고 사용자의 현재 위치를 표시합니다.

#### 3.1.2 기능 요구사항
- **FR-001-01**: 앱 시작 시 지도가 자동으로 로드되어야 함
- **FR-001-02**: 사용자의 현재 위치가 지도에 마커로 표시되어야 함
- **FR-001-03**: 지도는 줌 인/아웃, 팬(이동) 기능을 지원해야 함
- **FR-001-04**: 지도 타일은 오프라인 캐싱을 지원해야 함 (선택사항)
- **FR-001-05**: 지도 로드 실패 시 사용자에게 오류 메시지를 표시해야 함

#### 3.1.3 입력
- GPS 좌표 (위도, 경도)
- 지도 중심점 (초기값: 사용자 현재 위치)

#### 3.1.4 출력
- 지도 화면 표시
- 사용자 위치 마커

#### 3.1.5 처리
1. 앱 시작 시 위치 권한 확인
2. GPS로 현재 위치 획득
3. 지도 API를 통해 지도 타일 로드
4. 현재 위치를 지도 중심으로 설정

---

### 3.2 거리 입력 기능 (FR-002)

#### 3.2.1 설명
사용자가 러닝하고 싶은 거리를 킬로미터(km) 단위로 입력합니다.

#### 3.2.2 기능 요구사항
- **FR-002-01**: 사용자가 숫자 입력 필드를 통해 거리를 입력할 수 있어야 함
- **FR-002-02**: 입력 단위는 km로 고정
- **FR-002-03**: 입력 범위는 0.5km ~ 50km로 제한
- **FR-002-04**: 잘못된 입력(음수, 0, 범위 초과) 시 경고 메시지 표시
- **FR-002-05**: 빠른 입력을 위한 프리셋 버튼 제공 (5km, 10km, 15km, 21km 등)

#### 3.2.3 입력
- 사용자 입력: 거리 값 (km, 소수점 1자리까지)

#### 3.2.04 출력
- 입력된 거리 값
- 유효성 검증 결과

#### 3.2.5 처리
1. 사용자 입력 받기
2. 입력 값 유효성 검증 (범위, 형식)
3. 유효하지 않은 경우 오류 메시지 표시
4. 유효한 경우 다음 단계(코스 생성)로 진행

---

### 3.3 코스 생성 및 시뮬레이션 기능 (FR-003)

#### 3.3.1 설명
입력된 거리에 맞는 러닝 코스를 Distance-Constrained Loop Generation Algorithm v1.0을 사용하여 자동으로 생성하고 지도에 시뮬레이션하여 표시합니다. 이 알고리즘은 이상적인 원형 루프 모델을 기반으로 실제 도로망에 맞춰 폐곡선 루프를 생성합니다.

#### 3.3.2 기능 요구사항
- **FR-003-01**: 사용자 현재 위치를 시작점(S)으로 하는 폐곡선 루프 코스를 생성해야 함
- **FR-003-02**: 생성된 코스의 실제 거리 L은 입력된 거리 D의 ±10% 오차 범위 내여야 함 (기본 `tolerance_ratio = 0.1`)
- **FR-003-03**: 코스는 실제 도로/보행로를 따라 생성되어야 함
- **FR-003-04**: 생성된 코스는 지도에 폴리라인으로 표시되어야 함
- **FR-003-05**: 코스 생성 중 로딩 인디케이터와 진행 상태를 표시해야 함
- **FR-003-06**: 코스 생성 실패 시 사용자에게 재시도 옵션을 제공해야 함
- **FR-003-07**: 여러 개의 코스 후보를 생성하여 사용자가 선택할 수 있어야 함 (선택사항)
- **FR-003-08**: 코스 생성 시 고저차 정보를 미리 표시해야 함 (선택사항)
- **FR-003-09**: 알고리즘 실행 단계별 상태를 사용자에게 표시해야 함 (Step 기반 시도, S-P 기반 시도, Fallback 등)
- **FR-003-10**: 생성된 코스의 품질 지표를 표시해야 함 (자기 교차 최소화, 도로 적합성 등)

#### 3.3.3 입력
- **시작점**: 사용자 현재 위치 `S = (lat, lon)` (WGS84 좌표계)
- **목표 거리**: `D` (단위: km, 예: 5, 10, 15, 21 등)
- **알고리즘 파라미터** (기본값 사용 가능, 고급 사용자는 조정 가능):
  - `step_init`: 초기 스텝 길이 (기본값: 1.0 km)
  - `step_min`: 최소 스텝 길이 (기본값: 0.4 km)
  - `step_max`: 최대 스텝 길이 (기본값: 2.0 km)
  - `tolerance_ratio`: 허용 오차 비율 (기본값: 0.1 → ±10%)
  - `shrink_factor`: Step 축소 계수 (기본값: 0.8)
  - `grow_factor`: Step 확대 계수 (기본값: 1.2)
  - `max_iter`: 최대 반복 횟수 (기본값: 5~7)
  - `use_SP_fallback`: S-P 기반 Fallback 사용 여부 (기본값: True)

#### 3.3.4 출력
- **생성된 코스 데이터**:
  - 폴리라인 좌표 배열 (WGS84)
  - 코스 총 거리 `L` (km)
  - 상대 오차 `rel_error = |L - D| / D`
  - 사용된 알고리즘 (`STEP_ADAPTIVE`, `SP_BASED`, `FALLBACK`)
  - 반복 횟수
  - 사용된 step 값
- **코스 메타데이터**:
  - 예상 소요 시간 (분, 평균 페이스 기준)
  - 누적 고저차 (m, 선택사항)
  - 코스 품질 점수 (선택사항)
  - 자기 교차 횟수 (선택사항)
- **상태 정보**:
  - `status`: "OK" (tolerance 내), "BEST_EFFORT" (tolerance 초과), "FAIL" (생성 실패)

#### 3.3.5 처리 프로세스 (Distance-Constrained Loop Generation Algorithm v1.0)

**Phase 1: 초기화 및 기하학적 계산**
1. 사용자 현재 위치 `S = (lat, lon)` 획득
2. 목표 거리 `D` 입력 받기
3. 이상적인 원 반지름 계산: `R = D / (2π)`
4. 초기 step 값 설정: `step = step_init` (기본 1.0 km)

**Phase 2: Step 기반 + 양방향 Adaptive Step (메인 알고리즘)**
1. **Step 기반 원둘레 분할 루프 생성 (v0.2)**:
   - 예상 스텝 개수 계산: `N ≈ D / step`
   - 각도 증가량 계산: `Δθ = step / R`
   - 이상적인 포인트 Q 생성:
     - Q₀ = S (시작점)
     - Qᵢ = S 기준 반지름 R, 각도 i·Δθ 오프셋으로 생성
   - 각 Qᵢ를 도로상 포인트 Vᵢ로 스냅:
     - 주변 반경 100~300m 내 보행 가능한 노드 검색
     - 적절한 노드 없으면 θ 미세 조정 또는 스킵
   - Vᵢ → Vᵢ₊₁ 라우팅 (보행/러닝 모드)
   - Vₙ₋₁ → S 라우팅으로 루프 닫기
   - 전체 거리 L 계산

2. **양방향 Adaptive Step 피드백 (v0.3 확장)**:
   - 오차 계산: `error = |L - D|`, `rel_error = error / D`
   - 상태 판단:
     - `rel_error <= tolerance_ratio` → 성공, 결과 반환
     - `L > D` AND `rel_error > tolerance_ratio` → step 줄이기 (shrink)
       - `step_new = max(step * shrink_factor, step_min)`
     - `L < D` AND `rel_error > tolerance_ratio` → step 늘리기 (grow)
       - `step_new = min(step * grow_factor, step_max)`
   - 최대 `max_iter` 회까지 반복
   - 각 반복마다 best loop 갱신

**Phase 3: S-P 기반 Fallback (v0.1)**
- Step 기반 알고리즘이 허용 오차 내에 도달하지 못한 경우:
  1. `R = D / (2π)` 계산
  2. S-P 직선 목표 거리: `|SP| = D/π`
  3. 여러 방향(θ)으로 P 후보 생성 (예: 12방향, 30° 간격)
  4. 각 후보 P에 대해:
     - S → P 최단 경로 계산 (보행/러닝 모드)
     - P → S 최단 경로 계산 (가능하면 다른 길 유도)
  5. 루프 길이 `L = d(S→P) + d(P→S)` 계산
  6. `|L - D|` 및 품질 지표 기반으로 상위 루프 선택

**Phase 4: 최종 Fallback**
- S-P 기반도 만족스럽지 않을 때:
  1. **Out & Back**: S에서 D/2 근처까지 직선형 경로 라우팅 후 왕복
  2. **인기 루트 추천**: 해당 지역에서 자주 사용되는 코스 중 거리 근사값 추천

**Phase 5: 결과 선택 및 반환**
- Step 기반 결과와 S-P 기반 결과 비교:
  - 둘 중 `status`가 "OK"인 쪽 우선
  - 둘 다 "OK"면 `rel_error`가 작은 쪽 선택
  - 둘 다 "BEST_EFFORT"면 `rel_error`가 작은 쪽 선택

**Phase 6: 클라이언트 표시**
1. 생성된 코스 좌표를 받아 지도에 폴리라인으로 표시
2. 코스 정보(거리, 오차, 알고리즘, 반복 횟수 등) 표시
3. 사용자가 코스 선택 및 저장 가능

#### 3.3.6 알고리즘 특성 및 제약사항

**알고리즘의 강점:**
- 이상적인 원형 모델을 기반으로 자연스러운 루프 생성
- 양방향 Adaptive Step을 통한 정확도 향상
- 다단계 Fallback 전략으로 높은 성공률

**주요 기술적 허들:**
1. **도로 스냅 (Snap) 작업의 어려움**:
   - 이상적인 좌표 Qᵢ를 실제 도로 노드로 변환하는 과정
   - 주변 반경 내 적절한 노드가 없을 경우 처리 필요
   - 도로망 밀도가 낮은 지역에서 어려움

2. **라우팅 API 의존성**:
   - 각 구간(Vᵢ → Vᵢ₊₁)마다 라우팅 API 호출 필요
   - API 호출 횟수가 많아 비용 및 응답 시간 증가
   - Rate Limiting 및 타임아웃 처리 필요

3. **반복 계산의 복잡도**:
   - Adaptive Step을 통한 최대 `max_iter` 회 반복
   - 각 반복마다 전체 루프 생성 과정 재수행
   - 계산 시간이 거리와 step 값에 따라 증가

4. **도로망 데이터 품질**:
   - OSM 등 오픈소스 데이터의 지역별 품질 차이
   - 보행/러닝 모드 지원 여부
   - 도로 속성 정보의 정확도

#### 3.3.7 알고리즘 참조
- **Distance-Constrained Loop Generation Algorithm v1.0** 문서 상세 참조
- 알고리즘 구성 요소:
  - v0.1: S-P 기반 2-leg 루프
  - v0.2: 고정 Step 기반 원둘레 분할 루프
  - v0.3: 양방향 Adaptive Step 피드백
  - v1.0: 통합 버전 (Step 기반 + Adaptive + S-P Fallback)

---

### 3.4 코스 저장 기능 (FR-004)

#### 3.4.1 설명
생성된 코스를 로컬 저장소와 서버에 저장합니다.

#### 3.4.2 기능 요구사항
- **FR-004-01**: 생성된 코스를 로컬 저장소에 저장할 수 있어야 함
- **FR-004-02**: 코스에 사용자 정의 이름을 지정할 수 있어야 함
- **FR-004-03**: 코스에 태그 또는 카테고리 추가 가능 (선택사항)
- **FR-004-04**: 서버에 저장하여 다른 기기에서도 접근 가능해야 함
- **FR-004-05**: 오프라인 상태에서도 로컬 저장은 가능해야 함
- **FR-004-06**: 저장된 코스 목록을 조회할 수 있어야 함
- **FR-004-07**: 코스 저장 시 메타데이터 저장 (생성일시, 거리, 고저차 등)

#### 3.4.3 입력
- 코스 데이터:
  - 폴리라인 좌표 배열
  - 코스 이름
  - 거리 (km)
  - 메타데이터
- 공개 여부 설정 (선택사항)

#### 3.4.4 출력
- 저장 성공/실패 상태
- 저장된 코스 ID

#### 3.4.5 처리
1. 사용자가 코스 저장 요청
2. 코스 이름 입력 (필수)
3. 로컬 데이터베이스에 저장
4. 서버에 동기화 (온라인 상태인 경우)
5. 저장 완료 메시지 표시

---

### 3.5 코스 로드 기능 (FR-005)

#### 3.5.1 설명
저장된 코스를 불러와 지도에 표시합니다.

#### 3.5.2 기능 요구사항
- **FR-005-01**: 저장된 코스 목록을 조회할 수 있어야 함
- **FR-005-02**: 자신이 저장한 코스를 로드할 수 있어야 함
- **FR-005-03**: 다른 사용자가 공유한 코스를 로드할 수 있어야 함
- **FR-005-04**: 코스 목록에서 검색 기능 제공 (이름, 거리, 지역 등)
- **FR-005-05**: 코스 목록에 미리보기 정보 표시 (거리, 고저차, 평점 등)
- **FR-005-06**: 로드된 코스를 지도에 표시해야 함
- **FR-005-07**: 로드된 코스를 러닝에 사용할 수 있어야 함

#### 3.5.3 입력
- 코스 ID 또는 검색 조건

#### 3.5.4 출력
- 코스 목록
- 선택된 코스 데이터 (폴리라인, 메타데이터)

#### 3.5.5 처리
1. 코스 목록 화면 표시
2. 사용자가 코스 선택
3. 코스 데이터 로드 (로컬 또는 서버)
4. 지도에 코스 표시
5. 코스 정보 표시

---

### 3.6 러닝 추적 기능 (FR-006)

#### 3.6.1 설명
러닝 중 실시간으로 속도, 페이스, 고저차, 시간 등의 정보를 추적하고 표시합니다.

#### 3.6.1 기능 요구사항
- **FR-006-01**: 러닝 시작 시 GPS 추적을 시작해야 함
- **FR-006-02**: 현재 속도(km/h)를 실시간으로 표시해야 함
- **FR-006-03**: 현재 페이스(분/km)를 실시간으로 표시해야 함
- **FR-006-04**: 누적 거리(km)를 실시간으로 표시해야 함
- **FR-006-05**: 경과 시간을 표시해야 함 (시:분:초 형식)
- **FR-006-06**: 구간별 시간을 표시해야 함 (1km마다 또는 사용자 설정)
- **FR-006-07**: 누적 고저차(상승/하강)를 표시해야 함
- **FR-006-08**: 현재 고도(m)를 표시해야 함
- **FR-006-09**: 러닝 경로를 실시간으로 지도에 표시해야 함
- **FR-006-10**: 목표 코스와 현재 위치를 비교하여 경로 이탈 시 알림 제공
- **FR-006-11**: 러닝 일시정지/재개 기능 제공
- **FR-006-12**: 러닝 종료 시 결과 요약 화면 표시
- **FR-006-13**: 러닝 결과를 저장할 수 있어야 함

#### 3.6.3 입력
- GPS 좌표 (실시간)
- 가속도계 데이터 (선택사항, 보정용)
- 기압계 데이터 (선택사항, 고도 측정용)

#### 3.6.4 출력
- 실시간 러닝 통계:
  - 현재 속도 (km/h)
  - 현재 페이스 (분/km)
  - 누적 거리 (km)
  - 경과 시간 (시:분:초)
  - 구간별 시간 (배열)
  - 누적 상승 고도 (m)
  - 누적 하강 고도 (m)
  - 현재 고도 (m)
- 러닝 경로 폴리라인
- 러닝 완료 후 결과 요약

#### 3.6.5 처리
1. 사용자가 러닝 시작 버튼 클릭
2. GPS 추적 시작
3. 1초마다 GPS 좌표 수집
4. 좌표 기반으로 거리, 속도, 페이스 계산
5. 고도 데이터로 고저차 계산
6. UI에 실시간 업데이트
7. 러닝 종료 시 최종 통계 계산 및 저장

---

## 4. 비기능 요구사항 (Non-Functional Requirements)

### 4.1 성능 요구사항 (Performance Requirements)
- **PERF-001**: 코스 생성 응답 시간
  - S-P 기반 루프: 5초 이내 (단순 알고리즘)
  - Step 기반 루프 (1회): 10초 이내
  - Step 기반 + Adaptive (최대 반복): 30초 이내
  - **비동기 처리**: 코스 생성은 백그라운드에서 처리하고 진행 상태를 실시간으로 표시
- **PERF-002**: 지도 로드 시간은 3초 이내여야 함
- **PERF-003**: GPS 위치 업데이트 주기는 1초 이내여야 함
- **PERF-004**: 앱 시작 시간은 3초 이내여야 함
- **PERF-005**: 오프라인 모드에서도 저장된 코스 조회는 가능해야 함
- **PERF-006**: 라우팅 API 호출은 배치 처리하여 응답 시간 최적화
- **PERF-007**: 코스 생성 결과 캐싱으로 동일 요청 시 즉시 응답 (1초 이내)

### 4.2 보안 요구사항 (Security Requirements)
- **SEC-001**: 사용자 위치 정보는 암호화하여 전송해야 함
- **SEC-002**: API 키는 코드에 하드코딩하지 않고 안전하게 관리해야 함
- **SEC-003**: 사용자 데이터는 개인정보보호법을 준수해야 함
- **SEC-004**: 서버 통신은 HTTPS를 사용해야 함

### 4.3 사용성 요구사항 (Usability Requirements)
- **USE-001**: 직관적인 UI/UX로 5분 이내 사용법을 이해할 수 있어야 함
- **USE-002**: 주요 기능은 3회 이내의 터치로 접근 가능해야 함
- **USE-003**: 러닝 중에도 한 손으로 조작 가능한 UI 제공
- **USE-004**: 다크 모드 지원 (선택사항)

### 4.4 신뢰성 요구사항 (Reliability Requirements)
- **REL-001**: 앱 크래시율은 0.1% 이하여야 함
- **REL-002**: GPS 신호 약한 지역에서도 최대한 정확한 추적 제공
- **REL-003**: 네트워크 오류 시 적절한 오류 처리 및 재시도 로직

### 4.5 호환성 요구사항 (Compatibility Requirements)
- **COMP-001**: 안드로이드 8.0 (API 26) 이상 지원
- **COMP-002**: iOS 13.0 이상 지원
- **COMP-003**: 다양한 화면 크기 및 해상도 지원

### 4.6 유지보수성 요구사항 (Maintainability Requirements)
- **MAIN-001**: 코드는 Clean Architecture 원칙을 따라야 함
- **MAIN-002**: 핵심 로직의 테스트 커버리지는 70% 이상이어야 함
- **MAIN-003**: API 변경 시 하위 호환성 유지

---

## 5. 시스템 인터페이스 요구사항 (System Interfaces)

### 5.1 하드웨어 인터페이스
- **HW-001**: GPS 센서를 통한 위치 정보 수집
- **HW-002**: 가속도계를 통한 움직임 감지 (선택사항)
- **HW-003**: 기압계를 통한 고도 측정 (선택사항)

### 5.2 소프트웨어 인터페이스
- **SW-001**: 지도 API (Google Maps, Mapbox, OSM 등)
- **SW-002**: 라우팅 API (OSM, Google Directions API, Mapbox Directions API 등)
- **SW-003**: 백엔드 서버 API
- **SW-004**: 운영체제 API (위치 서비스, 파일 시스템 등)

### 5.3 통신 인터페이스
- **COMM-001**: HTTPS 프로토콜을 통한 서버 통신
- **COMM-002**: RESTful API 또는 GraphQL 사용
- **COMM-003**: WebSocket을 통한 실시간 업데이트 (선택사항)

---

## 6. 제약사항 및 기술적 허들 (Constraints and Technical Challenges)

### 6.1 기술 스택 (최종 결정)

#### 6.1.1 모바일 앱 개발 프레임워크

**선택: React Native (TypeScript) + Expo Bare Workflow** ⭐

- **선택 이유**: 지도 라이브러리 사용 가능, 크로스 플랫폼 개발 효율성, 네이티브 모듈 완전 지원
- **개발 방식**: Expo Bare Workflow
  - Expo 도구의 편의성 활용 (빠른 개발, OTA 업데이트 등)
  - 네이티브 코드 직접 관리 가능 (react-native-maps 등 네이티브 모듈 완전 지원)
  - 커스텀 네이티브 코드 추가 자유롭게 가능
- **장점**:
  - 하나의 코드베이스로 안드로이드/iOS 동시 개발
  - JavaScript/TypeScript 사용으로 개발 속도 빠름
  - 풍부한 라이브러리 생태계
  - 네이티브 모듈 연동 가능
  - Expo Dev Client로 빠른 개발 및 테스트
- **추천 라이브러리**:
  - 지도: `react-native-maps`
  - 위치: `@react-native-community/geolocation`
  - 네비게이션: `@react-navigation/native`
  - 상태 관리: `zustand` 또는 `redux-toolkit`
- **프로젝트 초기화**:
  ```bash
  npx create-expo-app@latest RunningMapApp --template bare
  ```

#### 6.1.2 백엔드 기술 스택

**서버 프레임워크: Python + FastAPI** ⭐

- **선택 이유**: 수학 라이브러리 사용 필요, 지리 데이터 처리 라이브러리 풍부
- **구현 전략**:
  - 개발 단계: 로컬 환경에서 FastAPI 서버 실행 (Docker Compose 사용)
  - 프로토타입: 로컬 또는 VPS에서 테스트
  - 프로덕션 단계: 클라우드 서버로 배포 (AWS, GCP 등)
- **추천 라이브러리**:
  - 웹 프레임워크: `FastAPI`
  - 지리 데이터: `GeoPy`, `Shapely`
  - 수학 계산: `numpy`, `scipy`
  - 비동기 HTTP: `httpx`
  - ORM: `SQLAlchemy`

**데이터베이스: PostgreSQL + PostGIS** ⭐

- **선택 이유**: 지리 검색에 유리한 DB 사용, 공간 쿼리 지원
- **구현 전략**:
  - 개발 단계: Docker로 로컬 PostgreSQL + PostGIS 실행
  - 프로토타입: 로컬 또는 VPS에서 테스트
  - 프로덕션 단계: 클라우드 관리형 서비스 또는 자체 서버

**캐싱 시스템: Redis** ⭐

- **선택 이유**: 많은 기능 제공, TTL 지원, 분산 캐싱 가능
- **구현 전략**:
  - 개발 단계: Docker로 로컬 Redis 실행
  - 프로토타입: 로컬 또는 VPS에서 테스트
  - 프로덕션 단계: 클라우드 관리형 서비스 또는 자체 서버
- **사용 사례**:
  - 코스 생성 결과 캐싱
  - 라우팅 결과 캐싱
  - 사용자 세션 관리

#### 6.1.3 지도 및 라우팅 API

**지도 API: OSM + react-native-maps + TileServer GL** ⭐

- **선택 이유**: 제약 없는 API로 데이터 확인 및 가공 가능, OSRM과 통합 운영
- **구성**:
  - 라이브러리: `react-native-maps`
  - 타일 서버: TileServer GL (Docker로 구축)
  - 데이터: OSM 데이터 (PBF → MBTiles 변환)
- **구현 전략**:
  - 개발 단계: MapTiler 무료 티어로 빠른 시작 (OSM 스타일)
  - 프로덕션 단계: TileServer GL 자체 서버 구축 및 운영
- **예상 비용**:
  - 개발 단계: 무료 (MapTiler 무료 티어)
  - 프로덕션: 서버 인프라 비용만 (약 $20-50/월)

**라우팅 API: OSRM (Open Source Routing Machine)** ⭐

- **선택 이유**: 로컬로 시험하다가 제품의 완성도가 높으면 서버 운영 예정
- **구현 전략**:
  - 개발 단계: Docker로 로컬 OSRM 서버 실행
  - 프로토타입: 로컬 또는 VPS에서 테스트
  - 프로덕션: 자체 서버 구축 및 운영
- **구현 방법**:
  - Docker 컨테이너로 OSRM 서버 구축
  - OSM 데이터 다운로드 및 처리
  - 자체 서버에서 호스팅
- **예상 비용**:
  - 개발 단계: 무료 (로컬)
  - 프로덕션: 서버 인프라 비용 (약 $30-50/월)

#### 6.1.4 통신 프로토콜

**선택: RESTful API** ⭐

- **선택 이유**: 대중성, 구현 단순, 캐싱 용이
- **장점**:
  - 표준적이고 널리 사용됨
  - 구현 단순
  - 캐싱 용이
  - 문서화 용이

#### 6.1.5 인프라 및 배포

**선택: 추후 재고려** (단계별 접근)

- **개발 단계**: Docker Compose로 로컬 환경 구성
  - FastAPI 서버 (로컬)
  - PostgreSQL + PostGIS (Docker)
  - Redis (Docker)
  - OSRM (Docker)
  - TileServer GL (Docker, 선택사항)
- **프로토타입**: VPS 고려 ($30-50/월)
- **프로덕션**: 사용자 증가 시 클라우드 전환 검토 (AWS/GCP)

#### 6.1.6 선택사항 기능

- **오프라인 지도 캐싱**: 아니오
- **다크 모드**: 예
- **가속도계/기압계 센서 활용**: 예
- **WebSocket 실시간 업데이트**: 아니오

### 6.2 기술적 허들 및 해결 방안

#### 6.2.1 지도 정보를 통한 루프 생성의 어려움 (최우선 이슈)

**문제:**
Distance-Constrained Loop Generation Algorithm v1.0의 핵심 기술적 허들은 **이상적인 기하학적 모델을 실제 도로망에 맞추는 과정**입니다.

**주요 어려움:**

1. **도로 스냅 (Snap) 작업의 복잡성**:
   - 이상적인 원 위의 좌표 Qᵢ를 실제 도로 노드로 변환하는 과정
   - 주변 반경 100~300m 내 보행 가능한 노드 검색 필요
   - 도로망 밀도가 낮은 지역(교외, 산간 지역)에서 적절한 노드를 찾기 어려움
   - 도로가 없는 지역(강, 공원 내부 등)에서 스냅 실패 가능
   - **해결 방안**:
     - 반경을 점진적으로 확대 (100m → 200m → 300m)
     - 각도 θ를 미세 조정하여 주변 도로 탐색
     - 스냅 실패 시 해당 포인트 스킵 및 다음 포인트로 진행
     - 도로망 데이터 품질 사전 검증

2. **라우팅 API 호출의 대량성**:
   - Step 기반 알고리즘에서 각 구간(Vᵢ → Vᵢ₊₁)마다 라우팅 API 호출 필요
   - 10km 코스의 경우 약 10~20회의 라우팅 API 호출 필요
   - Adaptive Step 반복 시 호출 횟수 증가 (최대 `max_iter` 회)
   - **해결 방안**:
     - 라우팅 결과를 Redis에 캐싱 (동일 구간 재사용)
     - 배치 라우팅 API 사용 (여러 구간을 한 번에 요청)
     - OSRM 등 자체 서버 구축으로 비용 절감
     - 타임아웃 및 재시도 로직 구현

3. **Adaptive Step 반복의 계산 비용**:
   - 각 반복마다 전체 루프 생성 과정 재수행
   - 최대 `max_iter`(5~7회) 반복 시 계산 시간 증가
   - **해결 방안**:
     - 서버 측 비동기 처리 (백그라운드 작업)
     - 진행 상태를 WebSocket으로 실시간 전송
     - 이전 반복 결과를 재사용하여 최적화
     - 조기 종료 조건 추가 (수렴 감지)

4. **도로망 데이터 품질의 지역별 차이**:
   - OSM 등 오픈소스 데이터의 지역별 완성도 차이
   - 도시 지역: 상세한 보행로 정보
   - 교외/농촌 지역: 도로 정보 부족
   - 보행/러닝 모드 지원 여부 불확실
   - **해결 방안**:
     - 여러 데이터 소스 병합 (OSM + Google Maps)
     - 지역별 데이터 품질 사전 검증
     - 사용자에게 데이터 품질 경고 표시
     - Fallback 전략 강화 (S-P 기반, Out & Back)

5. **루프 닫힘 보장의 어려움**:
   - Vₙ₋₁ → S 라우팅으로 루프를 닫는 과정
   - 마지막 구간이 목표 거리와 맞지 않을 수 있음
   - **해결 방안**:
     - 루프 닫힘 구간을 여러 경로 후보로 시도
     - 마지막 구간 조정을 통한 거리 보정
     - 루프가 닫히지 않을 경우 Fallback 전략 사용

6. **자기 교차 및 품질 평가**:
   - 생성된 루프의 자기 교차 감지 및 최소화
   - 도로 적합성 평가 (차도 vs 보행로)
   - **해결 방안**:
     - 폴리라인 교차점 검사 알고리즘
     - 도로 속성 기반 스코어링
     - 여러 후보 생성 후 품질 점수로 선택

**알고리즘 구현 우선순위:**
1. **Phase 1 (MVP)**: S-P 기반 루프만 구현 (단순하고 빠름)
2. **Phase 2**: Step 기반 루프 구현 (도로 스냅 로직)
3. **Phase 3**: Adaptive Step 피드백 추가
4. **Phase 4**: Fallback 전략 강화

#### 6.2.2 GPS 정확도 문제
**문제:**
- 실내 또는 건물 사이에서 GPS 신호 약함
- 위치 오차로 인한 거리 계산 부정확

**해결 방안:**
- GPS + 가속도계 + 자이로스코프 융합 (센서 퓨전)
- 칼만 필터를 통한 위치 보정
- 이동 평균을 통한 노이즈 제거
- 사용자에게 "GPS 신호 약함" 경고 표시

#### 6.2.3 배터리 소모
**문제:**
- GPS 추적 시 배터리 소모가 심함
- 지도 렌더링으로 인한 추가 배터리 소모

**해결 방안:**
- GPS 업데이트 주기 최적화 (러닝 중: 1초, 대기 중: 5초)
- 지도 타일 캐싱으로 네트워크 사용 최소화
- 배경 모드에서 최소한의 처리만 수행
- 사용자에게 배터리 절약 모드 옵션 제공

#### 6.2.4 오프라인 지원
**문제:**
- 네트워크 없이도 기본 기능 사용 필요
- 지도 타일 및 코스 데이터 오프라인 저장
- **코스 생성은 온라인 필수** (라우팅 API 필요)

**해결 방안:**
- 로컬 데이터베이스 사용 (SQLite, Realm 등)
- 지도 타일 오프라인 다운로드 기능
- 저장된 코스는 오프라인에서도 조회 가능
- 러닝 추적은 오프라인에서도 작동
- 코스 생성은 온라인 상태에서만 가능 (사용자에게 명확히 안내)

#### 6.2.5 지리 데이터 처리
**문제:**
- 대용량 지리 데이터 처리
- 좌표계 변환 및 거리 계산 정확도
- 지구 곡률을 고려한 거리 계산

**해결 방안:**
- PostGIS 또는 지리 데이터 전용 라이브러리 사용
- Haversine 또는 Vincenty 공식 사용 (알고리즘 문서 참조)
- 좌표계 통일 (WGS84, EPSG:4326)
- 부동소수점 오차 처리 (epsilon 값 사용)
- 지리 좌표 변환 라이브러리 표준화 (GeoPy, Shapely, Turf.js)

#### 6.2.6 API 비용 관리
**문제:**
- 지도 API 및 라우팅 API 사용량에 따른 비용 증가
- **코스 생성 시 다수의 라우팅 API 호출로 인한 비용 폭증**

**해결 방안:**
- **라우팅 결과 적극적인 캐싱** (Redis, 동일 구간 재사용)
- 무료/오픈소스 API 우선 사용 (OSRM 자체 서버 구축 권장)
- 사용량 모니터링 및 알림 설정
- Rate Limiting 구현
- 배치 라우팅 API 사용 (여러 구간을 한 번에 요청)
- 코스 생성 결과 캐싱 (동일 시작점 + 거리 조합)

#### 6.2.7 크로스 플랫폼 일관성
**문제:**
- 안드로이드와 iOS 간 UI/UX 차이
- 플랫폼별 기능 차이

**해결 방안:**
- Material Design (안드로이드) 및 Human Interface Guidelines (iOS) 준수
- 플랫폼별 네이티브 모듈 사용
- 통합 테스트를 통한 일관성 검증

### 6.3 성능 최적화 전략

1. **코스 생성 최적화 (핵심)**
   - **라우팅 결과 캐싱**: 동일 구간(Vᵢ → Vⱼ) 재사용
   - **코스 생성 결과 캐싱**: 동일 시작점 + 거리 조합 재사용
   - **서버 측 비동기 처리**: 코스 생성은 백그라운드 작업으로 처리
   - **진행 상태 실시간 전송**: WebSocket을 통한 진행률 업데이트
   - **조기 종료**: 수렴 감지 시 반복 조기 종료
   - **병렬 처리**: 여러 P 후보 또는 여러 방향 동시 처리
   - **인기 지역 사전 계산**: 자주 사용되는 지역의 코스 사전 생성

2. **지도 렌더링 최적화**
   - 타일 캐싱
   - 필요 영역만 로드
   - 폴리라인 단순화 (Douglas-Peucker 알고리즘)
   - 뷰포트 기반 렌더링 (화면에 보이는 부분만)

3. **데이터 동기화 최적화**
   - 증분 동기화
   - 배치 처리
   - 오프라인 큐 사용

4. **알고리즘 파라미터 튜닝**
   - 지역별 최적 `step_init` 값 설정
   - 도시/교외/산간 지역별 다른 파라미터 사용
   - 사용자 피드백 기반 파라미터 자동 조정

### 6.4 보안 고려사항

1. **위치 정보 보호**
   - 위치 데이터 암호화
   - 서버 전송 시 HTTPS 필수
   - 사용자 동의 없이 위치 공유 금지

2. **API 키 관리**
   - 환경 변수 또는 Keychain/Keystore 사용
   - 코드에 하드코딩 금지
   - 서버 측 프록시를 통한 API 호출 (선택사항)

3. **사용자 데이터 보호**
   - 개인정보 암호화 저장
   - GDPR 및 개인정보보호법 준수
   - 데이터 삭제 기능 제공

---

## 7. 용어집 (Glossary)

- **폴리라인 (Polyline)**: 여러 좌표점을 연결한 선
- **페이스 (Pace)**: 1km를 달리는 데 걸리는 시간 (분/km)
- **고저차 (Elevation Gain/Loss)**: 누적 상승/하강 고도
- **루프 (Loop)**: 시작점으로 돌아오는 폐곡선 경로
- **스냅 (Snap)**: 이상적인 좌표를 실제 도로 노드에 맞추는 작업
- **TTL (Time To Live)**: 캐시 데이터의 유효 기간

---

## 8. 부록 (Appendix)

### 8.1 우선순위 매트릭스

| 기능 | 우선순위 | 비고 |
|------|---------|------|
| 맵 로드 | 높음 | 핵심 기능 |
| 거리 입력 | 높음 | 핵심 기능 |
| 코스 생성 | 높음 | 핵심 기능 |
| 코스 저장 | 중간 | 필수 기능 |
| 코스 로드 | 중간 | 필수 기능 |
| 러닝 추적 | 높음 | 핵심 기능 |
| 다른 사용자 코스 공유 | 낮음 | 향후 기능 |

### 8.2 개발 단계 제안

**Phase 1: MVP (Minimum Viable Product)**
- 맵 로드
- 거리 입력
- 기본 코스 생성
- 러닝 추적 (기본 통계)

**Phase 2: 핵심 기능 완성**
- 코스 저장/로드
- 고저차 계산
- 구간별 시간

**Phase 3: 고급 기능**
- 다른 사용자 코스 공유
- 코스 추천
- 소셜 기능

---

**문서 끝**

